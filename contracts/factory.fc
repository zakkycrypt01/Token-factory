#include "imports/stdlib.fc";

;; Dictionary to store deployed token and NFT addresses (sender -> contract address)
dict deployed_tokens;
dict deployed_nfts;

;; Code cells for token and NFT contracts
cell token_code;
cell nft_code;

() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) {
  ;; Extract the sender address
  slice sender = get_sender_address(in_msg_full);
  
  ;; Extract the command from the message body (32-bit command ID)
  int command = in_msg_body~load_uint(32);
  
  ;; Command to deploy a new token contract
  if (command == 0x1) {
    deploy_token(sender, in_msg_body);
  }
  
  ;; Command to deploy a new NFT contract
  if (command == 0x2) {
    deploy_nft(sender, in_msg_body);
  }
}

;; Function to deploy a new token contract
() deploy_token(slice sender, slice in_msg_body) {
  ;; Create the state initialization data for the new token contract
  cell token_init = prepare_init_data(sender, token_code);
  
  ;; Deploy the new token contract and get the address
  slice token_address = deploy_contract(token_init, 0.1 ton);

  ;; Store deployed token address in the dictionary
  deployed_tokens = deployed_tokens.set(sender, token_address);
  
  ;; Send the token contract address back to the sender
  send_message(sender, token_address);
}

;; Function to deploy a new NFT contract
() deploy_nft(slice sender, slice in_msg_body) {
  ;; Create the state initialization data for the new NFT contract
  cell nft_init = prepare_init_data(sender, nft_code);

  ;; Deploy the new NFT contract and get the address
  slice nft_address = deploy_contract(nft_init, 0.1 ton);

  ;; Store deployed NFT address in the dictionary
  deployed_nfts = deployed_nfts.set(sender, nft_address);
  
  ;; Send the NFT contract address back to the sender
  send_message(sender, nft_address);
}

;; Helper function to prepare initialization data for contract deployment
cell prepare_init_data(slice owner, cell contract_code) {
  ;; Create initialization data with the owner's address
  cell init_data = begin_cell().store_slice(owner).end_cell();
  
  ;; Create the state initialization cell by combining contract code and init data
  cell state_init = begin_cell().store_ref(contract_code).store_ref(init_data).end_cell();
  
  return state_init;
}

;; Helper function to deploy the contract and return the new address
slice deploy_contract(cell state_init, int amount) {
  ;; Create the contract and send funds to it for initialization
  slice new_contract_address = create_new_contract(state_init, amount);
  
  return new_contract_address;
}

;; Helper function to extract sender address from the incoming message
slice get_sender_address(cell in_msg_full) {
  ;; Skip the first 256 bits (which could contain other message data) to get sender address
  slice sender_info = in_msg_full~load_slice().skip_bits(256);
  return sender_info;
}

;; Helper function to send a message back to the sender
() send_message(slice to, slice payload) {
  ;; Send the response using send_raw_message
  send_raw_message(begin_cell().store_slice(to).store_ref(begin_cell().store_slice(payload).end_cell()).end_cell(), 0);
}
