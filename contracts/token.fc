#include "imports/stdlib.fc";


;; Dictionary to store token balances
dict balances;

;; Address of the token owner
slice owner_address;

;; Total supply of the token
var total_supply;

() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) {
  ;; Extract sender address
  slice sender = get_sender_address(in_msg_full);
  
  ;; Command for token actions (mint, transfer)
  int command = in_msg_body~load_uint(32);
  
  ;; Mint tokens
  if (command == 0x1) {
    mint_tokens(sender, in_msg_body);
  }
  
  ;; Transfer tokens
  if (command == 0x2) {
    transfer_tokens(sender, in_msg_body);
  }
}

;; Mint new tokens (only the owner can mint)
() mint_tokens(slice sender, slice in_msg_body) {
  ;; Ensure only the owner can mint tokens
  if (sender != owner_address) {
    throw(101);  ;; Unauthorized access
  }

  ;; Load the amount to be minted
  int mint_amount = in_msg_body~load_uint(64);
  
  ;; Update total supply
  total_supply = total_supply + mint_amount;
  
  ;; Update owner's balance
  var current_balance = balances.at(owner_address).get_or_default(0);
  balances = balances.set(owner_address, current_balance + mint_amount);
}

;; Transfer tokens from sender to another address
() transfer_tokens(slice sender, slice in_msg_body) {
  ;; Load receiver address and amount
  slice receiver = in_msg_body~load_msg_addr();
  int transfer_amount = in_msg_body~load_uint(64);
  
  ;; Check sender's balance
  var sender_balance = balances.at(sender).get_or_default(0);
  if (sender_balance < transfer_amount) {
    throw(102);  ;; Insufficient balance
  }
  
  ;; Update balances
  balances = balances.set(sender, sender_balance - transfer_amount);
  
  ;; Update receiver's balance
  var receiver_balance = balances.at(receiver).get_or_default(0);
  balances = balances.set(receiver, receiver_balance + transfer_amount);
}

;; Get the sender's address from the incoming message
slice get_sender_address(cell in_msg_full) {
  slice sender_info = in_msg_full~load_slice().skip_bits(256);
  return sender_info;
}
